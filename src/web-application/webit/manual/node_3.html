<html><head><title>WebIt! Reference Manual</title><meta name="generator" content="WebIt!" /><meta name="robots" content="index,follow" /><link rel="stylesheet" href="./default.css" type="text/css" /></head><body><p /><div align="right" class="navigation">[Go to <a href="./index.html">first</a>, <a href="./node_2.html">previous</a>, <a href="./node_4.html">next</a> page; <a href="./index.html#toc_start">contents</a>]</div><div><a name="container_212" /><h1><a href="./index.html#toc_container_212">2&nbsp;Pattern Matching of XML</a></h1><div><a name="container_213" /><h2><a href="./index.html#toc_container_213">2.1&nbsp;<code class="scheme"><span class="keyword">xml-match</span></code></a></h2><p><em>syntax</em></p><p><code class="scheme"><span class="keyword">xml-match</span></code> provides pattern matching of XML nodes. The pattern notation is based on that of Scheme's syntax-rules/syntax-case macro systems.</p><p>The grammar for the <code class="scheme"><span class="keyword">xml-match</span></code> syntax is given below:</p><div class="figure"><pre>match-form ::= <code class="scheme">(<span class="keyword">xml-match</span> </code>input-expression
                 clause+<code class="scheme">)</code>

clause ::= <code class="scheme">[</code>node-pattern action-expression+<code class="scheme">]</code>
         | <code class="scheme">[</code>node-pattern <code class="scheme">(<span class="variable">guard</span> </code>expression*<code class="scheme">)</code> action-expression+<code class="scheme">]</code>

node-pattern ::= literal-pattern
               | pat-var-or-cata
               | element-pattern
               | list-pattern

literal-pattern ::= string
                  | character
                  | number
                  | <code class="scheme"><span class="selfeval">#t</span></code>
                  | <code class="scheme"><span class="selfeval">#f</span></code>

attribute-pattern ::= attribute-keyword attr-val-pattern

attr-val-pattern ::= literal-pattern
                   | pat-var-or-cata
                   | <code class="scheme">(</code>pat-var-or-cata default-value-expr<code class="scheme">)</code>

element-pattern ::= <code class="scheme">(</code>tag-symbol attribute-pattern*<code class="scheme">)</code>
                  | <code class="scheme">(</code>tag-symbol attribute-pattern* nodeset-pattern<code class="scheme">)</code>
                  | <code class="scheme">(</code>tag-symbol attribute-pattern*
                                nodeset-pattern? <code class="scheme">.</code> pat-var-or-cata<code class="scheme">)</code>

list-pattern ::= <code class="scheme">(<span class="builtin">list</span></code> nodeset-pattern<code class="scheme">)</code>
               | <code class="scheme">(<span class="builtin">list</span></code> nodeset-pattern? <code class="scheme">.</code> pat-var-or-cata<code class="scheme">)</code>
               | <code class="scheme">(<span class="builtin">list</span>)</code>

nodeset-pattern ::= node-pattern
                  | node-pattern <code class="scheme"><span class="variable">...</span></code>
                  | node-pattern nodeset-pattern
                  | node-pattern <code class="scheme"><span class="variable">...</span></code> nodeset-pattern

pat-var-or-cata ::= <code class="scheme">(<span class="keyword">unquote</span></code> var-symbol<code class="scheme">)</code>
                  | <code class="scheme">(<span class="keyword">unquote</span> [</code>var-symbol*<code class="scheme">])</code>
                  | <code class="scheme">(<span class="keyword">unquote</span> [</code>cata-expression <code class="scheme"><span class="variable">-&gt;</span></code> var-symbol*<code class="scheme">])</code>
</pre></div><p>Within a list or element body pattern, ellipses may appear only once, but may be followed by zero or more node patterns.</p><p>Guard expressions cannot refer to the return values of catamorphisms.</p><p>Ellipses in the output expressions must appear only in an expression context; ellipses are not allowed in a syntactic form.</p><p>The sections below illustrate specific aspects of the <code class="scheme"><span class="keyword">xml-match</span></code> pattern matcher.</p><div><a name="container_214" /><h3>Matching XML Elements</h3><p>The example below illustrates the pattern matching of an XML element:</p><pre class="scheme">(<span class="keyword">xml-match</span> (<span class="variable">e</span> <span class="variable">i:</span> <span class="selfeval">1</span> <span class="selfeval">3</span> <span class="selfeval">4</span> <span class="selfeval">5</span>)
  [(<span class="variable">e</span> <span class="variable">i:</span> <span class="keyword">,</span><span class="variable">d</span> <span class="keyword">,</span><span class="variable">a</span> <span class="keyword">,</span><span class="variable">b</span> <span class="keyword">,</span><span class="variable">c</span>) (<span class="builtin">list</span> <span class="variable">d</span> <span class="variable">a</span> <span class="variable">b</span> <span class="variable">c</span>)]
  [<span class="keyword">,</span><span class="variable">otherwise</span> <span class="selfeval">#f</span>])
</pre><p>The element and attribute tags used in patterns are the element and attribute constructors created by <code class="scheme"><span class="keyword">define-element</span></code> and <code class="scheme"><span class="keyword">define-attribute</span></code>. Each clause in <code class="scheme"><span class="keyword">xml-match</span></code> contains two parts: a pattern and one or more expressions which are evaluated if the pattern is successfully match.</p><p>Pattern variables are must be "unquoted" in the pattern. The above expression binds <code class="scheme"><span class="variable">d</span></code> to <code class="scheme"><span class="selfeval">1</span></code>, <code class="scheme"><span class="variable">a</span></code> to <code class="scheme"><span class="selfeval">3</span></code>, <code class="scheme"><span class="variable">b</span></code> to <code class="scheme"><span class="selfeval">4</span></code>, and <code class="scheme"><span class="variable">c</span></code> to <code class="scheme"><span class="selfeval">5</span></code>.</p></div><div><a name="container_215" /><h3>Matching Nodesets</h3><p>A nodeset pattern is designated by a list in the pattern, beginning the identifier <code class="scheme"><span class="builtin">list</span></code>. The example below illustrates matching a nodeset.</p><pre class="scheme">(<span class="keyword">xml-match</span> <span class="keyword">'</span>(<span class="selfeval">"i"</span> <span class="selfeval">"j"</span> <span class="selfeval">"k"</span> <span class="selfeval">"l"</span> <span class="selfeval">"m"</span>)
  [(<span class="builtin">list</span> <span class="keyword">,</span><span class="variable">a</span> <span class="keyword">,</span><span class="variable">b</span> <span class="keyword">,</span><span class="variable">c</span> <span class="keyword">,</span><span class="variable">d</span> <span class="keyword">,</span><span class="variable">e</span>)
   (<span class="builtin">list</span> (<span class="variable">h4:p</span> <span class="variable">a</span>) (<span class="variable">h4:p</span> <span class="variable">b</span>) (<span class="variable">h4:p</span> <span class="variable">c</span>) (<span class="variable">h4:p</span> <span class="variable">d</span>) (<span class="variable">h4:p</span> <span class="variable">e</span>))])
</pre><p>This example wraps each nodeset item in an HTML paragraph element.</p></div><div><a name="container_216" /><h3>Matching the 'Rest' of a Nodeset</h3><p>Matching the 'rest' of a nodeset is achieved by using a "<code class="scheme">. <span class="variable">rest</span>)</code>" pattern at the end of an element or nodeset pattern.</p><p>This is illustrated in the example below:</p><pre class="scheme">(<span class="keyword">xml-match</span> (<span class="variable">e</span> <span class="selfeval">3</span> (<span class="variable">f</span> <span class="selfeval">4</span> <span class="selfeval">5</span> <span class="selfeval">6</span>) <span class="selfeval">7</span>)
  [(<span class="variable">e</span> <span class="keyword">,</span><span class="variable">a</span> (<span class="variable">f</span> . <span class="keyword">,</span><span class="variable">y</span>) <span class="keyword">,</span><span class="variable">d</span>)
   (<span class="builtin">list</span> <span class="variable">a</span> <span class="variable">y</span> <span class="variable">d</span>)])
</pre><p>The above expression returns <code class="scheme">(<span class="selfeval">3</span> (<span class="selfeval">4</span> <span class="selfeval">5</span> <span class="selfeval">6</span>) <span class="selfeval">7</span>)</code>.</p></div><div><a name="container_217" /><h3>Ellipses in Patterns</h3><p>As in <code class="scheme"><span class="keyword">syntax-rules</span></code>, ellipses may be used to specify a repeated pattern. Note that the pattern "<code class="scheme"><span class="variable">item</span> <span class="variable">...</span></code>" specifies zero-or-more matches of the pattern "<code class="scheme"><span class="variable">item</span></code>".</p><p>The use of ellipses in a pattern is illustrated in the code fragment below, where nested ellipses are used to match the children of repeated instances of an 'a' element, within an element 'd'.</p><pre class="scheme">(<span class="keyword">define</span> <span class="variable">x</span> (<span class="variable">d</span> (<span class="variable">a</span> <span class="selfeval">1</span> <span class="selfeval">2</span> <span class="selfeval">3</span>) (<span class="variable">a</span> <span class="selfeval">4</span> <span class="selfeval">5</span>) (<span class="variable">a</span> <span class="selfeval">6</span> <span class="selfeval">7</span> <span class="selfeval">8</span>) (<span class="variable">a</span> <span class="selfeval">9</span> <span class="selfeval">10</span>)))

(<span class="keyword">xml-match</span> <span class="variable">x</span>
  [(<span class="variable">d</span> (<span class="variable">a</span> <span class="keyword">,</span><span class="variable">b</span> <span class="variable">...</span>) <span class="variable">...</span>)
   (<span class="builtin">list</span> (<span class="builtin">list</span> <span class="variable">b</span> <span class="variable">...</span>) <span class="variable">...</span>)])
</pre><p>The above expression returns a value of <code class="scheme">((<span class="selfeval">1</span> <span class="selfeval">2</span> <span class="selfeval">3</span>) (<span class="selfeval">4</span> <span class="selfeval">5</span>) (<span class="selfeval">6</span> <span class="selfeval">7</span> <span class="selfeval">8</span>) (<span class="selfeval">9</span> <span class="selfeval">10</span>))</code>.</p></div><div><a name="container_218" /><h3>Default Values in Attribute Patterns</h3><p>It is possible to specify a default value for an attribute which is used if the attribute is not present in the element being matched. This is illustrated in the following example:</p><pre class="scheme">(<span class="keyword">xml-match</span> (<span class="variable">e</span> <span class="selfeval">3</span> <span class="selfeval">4</span> <span class="selfeval">5</span>)
  [(<span class="variable">e</span> <span class="variable">z:</span> (<span class="keyword">,</span><span class="variable">d</span> <span class="selfeval">1</span>) <span class="keyword">,</span><span class="variable">a</span> <span class="keyword">,</span><span class="variable">b</span> <span class="keyword">,</span><span class="variable">c</span>) (<span class="builtin">list</span> <span class="variable">d</span> <span class="variable">a</span> <span class="variable">b</span> <span class="variable">c</span>)])
</pre><p>The value <code class="scheme"><span class="selfeval">1</span></code> is used when the attribute 'z' is absent from the element 'e'.</p></div><div><a name="container_219" /><h3>Guards in Patterns</h3><p>Guards may be added to a pattern clause via the <code class="scheme"><span class="variable">guard</span></code> keyword. A guard expression may include zero or more expressions which are evaluated only if the pattern is matched. The body of the clause is only evaluated if the guard expressions evaluate to <code class="scheme"><span class="selfeval">#t</span></code>.</p><p>The use of guard expressions is illustrated below:</p><pre class="scheme">(<span class="keyword">xml-match</span> <span class="keyword">'</span>(<span class="variable">a</span> <span class="selfeval">2</span> <span class="selfeval">3</span>)
  ((<span class="variable">a</span> <span class="keyword">,</span><span class="variable">n</span>) (<span class="variable">guard</span> (<span class="variable">number?</span> <span class="variable">n</span>)) <span class="variable">n</span>)
  ((<span class="variable">a</span> <span class="keyword">,</span><span class="variable">m</span> <span class="keyword">,</span><span class="variable">n</span>) (<span class="variable">guard</span> (<span class="variable">number?</span> <span class="variable">m</span>) (<span class="variable">number?</span> <span class="variable">n</span>)) (<span class="builtin">+</span> <span class="variable">m</span> <span class="variable">n</span>)))</pre></div><div><a name="container_220" /><h3>Catamorphisms</h3><p>The example below illustrates the use of explicit recursion within an xml-match form. This example implements a simple calculator for the basic arithmetic operations, which are represented by the XML elements plus, minus, times, and div.</p><pre class="scheme">(<span class="keyword">define</span> <span class="variable">simple-eval</span>
  (<span class="keyword">lambda</span> (<span class="variable">x</span>)
    (<span class="keyword">xml-match</span> <span class="variable">x</span>
      [<span class="keyword">,</span><span class="variable">i</span> (<span class="variable">guard</span> (<span class="variable">integer?</span> <span class="variable">i</span>)) <span class="variable">i</span>]
      [(<span class="variable">plus</span> <span class="keyword">,</span><span class="variable">x</span> <span class="keyword">,</span><span class="variable">y</span>) (<span class="builtin">+</span> (<span class="variable">simple-eval</span> <span class="variable">x</span>) (<span class="variable">simple-eval</span> <span class="variable">y</span>))]
      [(<span class="variable">times</span> <span class="keyword">,</span><span class="variable">x</span> <span class="keyword">,</span><span class="variable">y</span>) (<span class="builtin">*</span> (<span class="variable">simple-eval</span> <span class="variable">x</span>) (<span class="variable">simple-eval</span> <span class="variable">y</span>))]
      [(<span class="variable">minus</span> <span class="keyword">,</span><span class="variable">x</span> <span class="keyword">,</span><span class="variable">y</span>) (<span class="builtin">-</span> (<span class="variable">simple-eval</span> <span class="variable">x</span>) (<span class="variable">simple-eval</span> <span class="variable">y</span>))]
      [(<span class="variable">div</span> <span class="keyword">,</span><span class="variable">x</span> <span class="keyword">,</span><span class="variable">y</span>) (<span class="builtin">/</span> (<span class="variable">simple-eval</span> <span class="variable">x</span>) (<span class="variable">simple-eval</span> <span class="variable">y</span>))]
      [<span class="keyword">,</span><span class="variable">otherwise</span> (<span class="variable">error</span> <span class="selfeval">"simple-eval: invalid expression"</span> <span class="variable">x</span>)])))
</pre><p>Using the catamorphism feature of <code class="scheme"><span class="keyword">xml-match</span> </code>, a more concise version of <code class="scheme"><span class="variable">simple-eval</span></code> can be written. The pattern <code class="scheme"><span class="keyword">,</span>[<span class="variable">x</span>]</code> recusively invokes the pattern matcher on the value bound in this position.</p><pre class="scheme">(<span class="keyword">define</span> <span class="variable">simple-eval</span>
  (<span class="keyword">lambda</span> (<span class="variable">x</span>)
    (<span class="keyword">xml-match</span> <span class="variable">x</span>
      [<span class="keyword">,</span><span class="variable">i</span> (<span class="variable">guard</span> (<span class="variable">integer?</span> <span class="variable">i</span>)) <span class="variable">i</span>]
      [(<span class="variable">plus</span> <span class="keyword">,</span>[<span class="variable">x</span>] <span class="keyword">,</span>[<span class="variable">y</span>]) (<span class="builtin">+</span> <span class="variable">x</span> <span class="variable">y</span>)]
      [(<span class="variable">times</span> <span class="keyword">,</span>[<span class="variable">x</span>] <span class="keyword">,</span>[<span class="variable">y</span>]) (<span class="builtin">*</span> <span class="variable">x</span> <span class="variable">y</span>)]
      [(<span class="variable">minus</span> <span class="keyword">,</span>[<span class="variable">x</span>] <span class="keyword">,</span>[<span class="variable">y</span>]) (<span class="builtin">-</span> <span class="variable">x</span> <span class="variable">y</span>)]
      [(<span class="variable">div</span> <span class="keyword">,</span>[<span class="variable">x</span>] <span class="keyword">,</span>[<span class="variable">y</span>]) (<span class="builtin">/</span> <span class="variable">x</span> <span class="variable">y</span>)]
      [<span class="keyword">,</span><span class="variable">otherwise</span> (<span class="variable">error</span> <span class="selfeval">"simple-eval: invalid expression"</span> <span class="variable">x</span>)])))
</pre></div><div><a name="container_221" /><h3>Named-Catamorphisms</h3><p>It is also possible to explicitly name the operator in the 'cata' position. Where <code class="scheme"><span class="keyword">,</span>[<span class="variable">id*</span>]</code> recurs to the top of the current <code class="scheme"><span class="keyword">xml-match</span></code>, <code class="scheme"><span class="keyword">,</span>[<span class="variable">cata</span> <span class="variable">-&gt;</span> <span class="variable">id*</span>]</code> recurs to <code class="scheme"><span class="variable">cata</span></code>. <code class="scheme"><span class="variable">cata</span></code> must evaluate to a procedure which takes one argument, and returns as many values as there are identifiers following <code class="scheme"><span class="variable">-&gt;</span></code>.</p><p>Named catamorphism patterns allow processing to be split into multiple, mutually recursive procedures. This is illustrated in the example below: a transformation that formats a "TV Guide" into HTML.</p><pre class="scheme">(<span class="keyword">define</span> (<span class="variable">tv-guide-&gt;html</span> <span class="variable">g</span>)
  (<span class="keyword">define</span> (<span class="variable">cast-list</span> <span class="variable">cl</span>)
    (<span class="keyword">xml-match</span> <span class="variable">cl</span>
      [(<span class="variable">CastList</span> (<span class="variable">CastMember</span> (<span class="variable">Character</span> (<span class="variable">Name</span> <span class="keyword">,</span><span class="variable">ch</span>)) (<span class="variable">Actor</span> (<span class="variable">Name</span> <span class="keyword">,</span><span class="variable">a</span>))) <span class="variable">...</span>)
       (<span class="variable">h4:div</span> (<span class="variable">h4:ul</span> (<span class="variable">h4:li</span> <span class="variable">ch</span> <span class="selfeval">": "</span> <span class="variable">a</span>) <span class="variable">...</span>))]))
  (<span class="keyword">define</span> (<span class="variable">prog</span> <span class="variable">p</span>)
    (<span class="keyword">xml-match</span> <span class="variable">p</span>
      [(<span class="variable">Program</span> (<span class="variable">Start</span> <span class="keyword">,</span><span class="variable">start-time</span>) (<span class="variable">Duration</span> <span class="keyword">,</span><span class="variable">dur</span>) (<span class="variable">Series</span> <span class="keyword">,</span><span class="variable">series-title</span>)
                (<span class="variable">Description</span> . <span class="keyword">,</span><span class="variable">desc</span>))
       (<span class="variable">h4:div</span> (<span class="variable">h4:p</span> <span class="variable">start-time</span>
                     (<span class="variable">h4:br</span>) <span class="variable">series-title</span>
                     (<span class="variable">h4:br</span>) <span class="variable">desc</span>))]
      [(<span class="variable">Program</span> (<span class="variable">Start</span> <span class="keyword">,</span><span class="variable">start-time</span>) (<span class="variable">Duration</span> <span class="keyword">,</span><span class="variable">dur</span>) (<span class="variable">Series</span> <span class="keyword">,</span><span class="variable">series-title</span>)
                (<span class="variable">Description</span> . <span class="keyword">,</span><span class="variable">desc</span>)
                <span class="keyword">,</span>[<span class="variable">cast-list</span> <span class="variable">-&gt;</span> <span class="variable">cl</span>])
       (<span class="variable">h4:div</span> (<span class="variable">h4:p</span> <span class="variable">start-time</span>
                     (<span class="variable">h4:br</span>) <span class="variable">series-title</span>
                     (<span class="variable">h4:br</span>) <span class="variable">desc</span>)
               <span class="variable">cl</span>)]))
  (<span class="keyword">xml-match</span> <span class="variable">g</span>
    [(<span class="variable">TVGuide</span> <span class="variable">start:</span> <span class="keyword">,</span><span class="variable">start-date</span>
              <span class="variable">end:</span> <span class="keyword">,</span><span class="variable">end-date</span>
              (<span class="variable">Channel</span> (<span class="variable">Name</span> <span class="keyword">,</span><span class="variable">nm</span>) <span class="keyword">,</span>[<span class="variable">prog</span> <span class="variable">-&gt;</span> <span class="variable">p</span>] <span class="variable">...</span>) <span class="variable">...</span>)
     (<span class="variable">h4:html</span> (<span class="variable">h4:head</span> (<span class="variable">h4:title</span> <span class="selfeval">"TV Guide"</span>))
              (<span class="variable">h4:body</span> (<span class="variable">h4:h1</span> <span class="selfeval">"TV Guide"</span>)
                       (<span class="variable">h4:div</span> (<span class="variable">h4:h2</span> <span class="variable">nm</span>) <span class="variable">p</span> <span class="variable">...</span>) <span class="variable">...</span>))]))
</pre></div><div><a name="container_222" /><h3>Ellipses in Quasiquote'd Output</h3><p>Within the body of an <code class="scheme"><span class="keyword">xml-match</span></code> form, a slightly extended version of <code class="scheme"><span class="keyword">quasiquote</span></code> is provided, which allows the use of ellipses. This is illustrated in the example below.</p><pre class="scheme">(<span class="keyword">xml-match</span> <span class="keyword">'</span>(<span class="variable">e</span> <span class="selfeval">3</span> <span class="selfeval">4</span> <span class="selfeval">5</span> <span class="selfeval">6</span> <span class="selfeval">7</span>)
  [(<span class="variable">e</span> <span class="keyword">,</span><span class="variable">i</span> <span class="variable">...</span> <span class="selfeval">6</span> <span class="selfeval">7</span>) <span class="keyword">`</span>(<span class="selfeval">"start"</span> <span class="keyword">,</span>(<span class="builtin">list</span> <span class="keyword">'</span><span class="variable">wrap</span> <span class="variable">i</span>) <span class="variable">...</span> <span class="selfeval">"end"</span>)]
  [<span class="keyword">,</span><span class="variable">otherwise</span> <span class="selfeval">#f</span>])
</pre><p>The general pattern is that <code class="scheme"><span class="keyword">`</span>(<span class="variable">something</span> <span class="keyword">,</span><span class="variable">i</span> <span class="variable">...</span>)</code> is rewritten as <code class="scheme"><span class="keyword">`</span>(<span class="variable">something</span> <span class="keyword">,@</span><span class="variable">i</span>)</code>.</p></div></div><div><a name="container_223" /><h2><a href="./index.html#toc_container_223">2.2&nbsp;<code class="scheme"><span class="keyword">xml-match-let</span></code> and <code class="scheme"><span class="keyword">xml-match-let*</span></code></a></h2><p><em>syntax</em></p><p>The <code class="scheme"><span class="keyword">xml-match-let</span></code> and <code class="scheme"><span class="keyword">xml-match-let*</span></code> forms generalize the <code class="scheme"><span class="keyword">let</span></code> and <code class="scheme"><span class="keyword">let*</span></code> forms of Scheme to allow an XML pattern in the binding position, rather than a simple variable.</p><p>For example, the expression below:</p><pre class="scheme">(<span class="keyword">xml-match-let</span> ([(<span class="variable">a</span> <span class="keyword">,</span><span class="variable">i</span> <span class="keyword">,</span><span class="variable">j</span>) <span class="keyword">'</span>(<span class="variable">a</span> <span class="selfeval">1</span> <span class="selfeval">2</span>)])
  (<span class="builtin">+</span> <span class="variable">i</span> <span class="variable">j</span>))
</pre><p>binds the variables <code class="scheme"><span class="variable">i</span></code> and <code class="scheme"><span class="variable">j</span></code> to 1 and 2 in the XML value given.</p><p>The syntax for these forms is given below:</p><pre>(xml-match-let ([pat expr] ...) expression0 expression ...)
(xml-match-let* ([pat expr] ...) expression0 expression ...)
</pre></div></div><p style="margin-top:24pt;">&nbsp;</p><p /><div align="right" class="navigation">[Go to <a href="./index.html">first</a>, <a href="./node_2.html">previous</a>, <a href="./node_4.html">next</a> page; <a href="./index.html#toc_start">contents</a>]</div><p>&nbsp;</p><div class="collophon" align="right">Last modified: Sunday, April 24th, 2005 2:52:27pm<br />HTML generated using <a href="http://celtic.benderweb.net/webit/">WebIt!</a>.</div></body></html>