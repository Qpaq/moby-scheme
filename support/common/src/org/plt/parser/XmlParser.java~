package org.plt.parser;

import org.plt.types.*;
import org.plt.Kernel;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.parsers.DocumentBuilder;

import java.io.ByteArrayInputStream;
import java.io.IOException;
import org.w3c.dom.Document;
import org.w3c.dom.Element;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;

public class XmlParser {

    // Given string s, parses it.
    public List parseXml(String s) {
	DocumentBuilder builder = DocumentBuildFactory.newInstance();
	Element topElement = 
	    builder.parse(new ByteArrayInputStream(s.getBytes())).getDocumentElement();
    }


    private List parseNode(Node n) {
	switch (n.getNodeType()) {
	case ATTRIBUTE_NODE:
	case CDATA_SECTION_NODE:
	case COMMENT_NODE:
	case DOCUMENT_FRAGMENT_NODE:
	case DOCUMENT_NODE:
	case DOCUMENT_TYPE_NODE:
	case ELEMENT_NODE:
	case ENTITY_NODE:
	case ENTITY_REFERENCE_NODE:
	case NOTATION_NODE:
	case PROCESSING_INSTRUCTION_NODE:
	case TEXT_NODE:
	default:
	    throw new RuntimeException("Impossible");
	}
	return null;
    }

    private List parseElement(Element e) {
	String tagName = n.getTagName();
	NodeList children = e.getChildNodes();

	List parsedChildren = Empty.EMPTY;
	parsedChildren = new Pair(tagName, parsedChildren);
	// Fixme: add attributes
	for(int i = 0; i < children.getLength(); i++) {
	    parsedChildren = new Pair(parseNode(children.item(i)),
				      parsedChildren);
	}
	return Kernel.reverse(parsedChildren);
    }
}