package org.plt.<<PROGRAM-NAME>>;

import javax.microedition.midlet.*;
import javax.microedition.lcdui.*;

import org.plt.platform.PlatformI;
import org.plt.platform.Platform;
import org.plt.MessageListener;
import org.plt.LocationChangeListener;
import org.plt.world.TiltChangeListener;
import org.plt.WorldKernel;


// This is stub code.
// The following things must be plugged in:
// 
// PROGRAM-NAME
// PROGRAM-DEFINITIONS


public class <<PROGRAM-NAME>> extends MIDlet {
    // Important: definitions must come first, because they'll
    // include static blocks that initialize values that
    // we depend on later!
    <<PROGRAM-DEFINITIONS>>

    // #0 big-bang's world0
    Object world = WorldKernel.getInitialWorld();

    // When a program is paused, we'll restart the world.
    public void pauseApp() {
	world = WorldKernel.getInitialWorld();
    }

    public void destroyApp(boolean unconditional) {}

    public void startApp() {
	// debug: show the platform in the log.
	System.out.println(Platform.getInstance().getName());

	MyCanvas canvas = new MyCanvas();

	Platform.getInstance().getLocationService().addLocationChangeListener(canvas);
	Platform.getInstance().getTiltService().addTiltChangeListener(canvas);

	Display.getDisplay(this).setCurrent(canvas);
	new Thread(canvas).start();
    }

    class MyCanvas extends Canvas implements Runnable, MessageListener, LocationChangeListener, TiltChangeListener {
	boolean stopped = false;
	public void run() {
	    // #1 delay expression
	    long delay = (long) ((org.plt.types.NumberTower.multiply
				  ((org.plt.types.Number)
				   WorldKernel.getFrameRate(),
				   new org.plt.types.Rational(1000, 1))).toInt());
	    while(! stopped) {
		repaint();
		if(((org.plt.types.Logic) WorldKernel.getStopWhenHandler().call(new Object[] {world})).isTrue()) {
		    //  #2 stop-when expression
		    stopped = true;
		} else {
		    try {
			Thread.sleep(delay);
		    } catch (InterruptedException e) {}
		    synchronized(world) {
			//  #3 on-tick expression
			world = WorldKernel.getOnTickHandler().call(new Object[] { world });
		    }
		}
	    }
	}

        public void onMessage(Object aMessage) {
	    synchronized(world) {
		world = WorldKernel.getOnMessageEventHandler().call
		    (new Object[] { world, aMessage});
	    }
	}

	public void onLocationChange(Object latitude, Object longitude) {
	    synchronized(world) {
		world = WorldKernel.getOnLocationChangeEventHandler().call
		    (new Object[] { world, latitude, longitude });
	    }	    
	}

	public void onTiltChange(Object x, Object y, Object z) {
	    synchronized(world) {
		world = WorldKernel.getOnTiltChangeEventHandler().call
		    (new Object[] { world, x, y, z });
	    }	    
	}

	public void paint(Graphics g) {
            org.plt.gui.GraphicsAdapter ag = new org.plt.gui.GraphicsAdapter(g);
	    // #4,5,6 on-redraw expression
	    org.plt.gui.DrawPicture pVisitor = new org.plt.gui.DrawPicture(ag);
	    org.plt.gui.Scene aScene = (org.plt.gui.Scene) WorldKernel.getOnRedrawHandler().call
		(new Object[] {world});
	    aScene.accept(pVisitor, 0, 0);
	}

	protected void keyPressed(int keyCode) {
	    Object aKey;
	    if (stopped) { return; }
	    switch(getGameAction(keyCode)) {
	    case Canvas.LEFT: aKey = "left"; break;
	    case Canvas.RIGHT: aKey = "right"; break;
	    case Canvas.UP: aKey = "up"; break;
	    case Canvas.DOWN: aKey = "down"; break;
	    default:
		if (keyCode > 0) {
		    aKey = new Character((char)keyCode);
		} else {
		    aKey= "";
		}
		break;
	    }
	    
	    synchronized(world) {
		world = WorldKernel.getOnKeyEventHandler().call
		    (new Object[] {world, aKey});
	    }
	    repaint();
	}
    }
}
