package org.plt.<<PROGRAM-NAME>>;

import javax.microedition.midlet.*;
import javax.microedition.lcdui.*;

import org.plt.platform.PlatformI;
import org.plt.platform.Platform;

import org.plt.world.WorldRunner;
import org.plt.world.WorldConsumer;
import org.plt.world.WorldTransformer;
import org.plt.WorldKernel;

import org.plt.world.MessageListener;
import org.plt.world.LocationChangeListener;
import org.plt.world.OrientationChangeListener;
import org.plt.world.AccelerationChangeListener;



// This is stub code.
// The following things must be plugged in:
// 
// PROGRAM-NAME
// PROGRAM-DEFINITIONS
// PROGRAM-TOPLEVEL-EXPRESSIONS
// ON-START
// ON-PAUSE
// ON-DESTROY


public class <<PROGRAM-NAME>> extends MIDlet 
    implements WorldConsumer,
	       MessageListener, 
	       LocationChangeListener, 
	       OrientationChangeListener,
	       AccelerationChangeListener  {
    static class UserProgram {
        // Important: definitions must come first, because they'll
        // include static blocks that initialize values that
        // we depend on later!
        <<PROGRAM-DEFINITIONS>>
        public static void runToplevel() {
	    <<PROGRAM-TOPLEVEL-EXPRESSIONS>>;
	}
    }

    MyCanvas canvas;
    WorldRunner runner;
    Object world;


    // When a program is paused, we'll restart the world.
    public void pauseApp() {
	world = WorldKernel.getInitialWorld();
	this.runner.stop();
	// IMPORTANT: The injected code here assumes the
	// presense of a 'listener' variable that
	// can be used to register callbacks.
	MyCanvas listener = canvas;
	<<ON-PAUSE>>
    }


    public void destroyApp(boolean unconditional) {
	world = WorldKernel.getInitialWorld();
	this.runner.stop();
	// IMPORTANT: The injected code here assumes the
	// presense of a 'listener' variable that
	// can be used to register callbacks.
	MyCanvas listener = canvas;
	<<ON-DESTROY>>
    }	


    public void startApp() {
	// debug: show the platform in the log.
	// System.out.println(Platform.getInstance().getName());
	this.world = null;
	this.runner = new WorldRunner();
	this.runner.addListener(this);
	WorldKernel.setRunner(this.runner);
	this.canvas = new MyCanvas();
	// IMPORTANT: The injected code here assumes the
	// presence of a 'listener' variable that
	// can be used to register callbacks.
	MyCanvas listener = canvas;
	<<ON-START>>
	Display.getDisplay(this).setCurrent(canvas);


	new Thread() {
	    public void run() {
		UserProgram.runToplevel();
	    }
	}.start();
    }


    // WorldConsumer: we get the new world and show it!
    public void consume(Object newWorld) {
	this.world = newWorld;
	if (this.canvas != null)
	    this.canvas.repaint();
    }


    public void onMessage(final Object aMessage) {
	this.runner.queueTransformer(new WorldTransformer() {
	    public Object transform(Object world) {
		return WorldKernel.getOnMessageEventHandler().call
		    (new Object[] { world, aMessage});
	    }
	    });
    }

    public void onLocationChange(final Object latitude,
				 final Object longitude) {
	this.runner.queueTransformer(new WorldTransformer() {
	    public Object transform(Object world) {
		return WorldKernel.getOnLocationChangeEventHandler().call
		    (new Object[] { world, latitude, longitude });
	    }
	    });
    }

    public void onOrientationChange(final Object azimuth, 
				    final Object pitch,
				    final Object roll) {
	this.runner.queueTransformer(new WorldTransformer() {
	    public Object transform(Object world) {
		return WorldKernel.getOnOrientationChangeEventHandler().call
		    (new Object[] { world, azimuth, pitch, roll });
	    }
	    });
    }


    public void onAccelerationChange(final Object x,
				     final Object y,
				     final Object z) {
	this.runner.queueTransformer(new WorldTransformer() {
	    public Object transform(Object world) {
		return WorldKernel.getOnAccelerationChangeEventHandler()
		    .call(new Object[] { world, x, y, z });
	    }
	    });
    }





    class MyCanvas extends Canvas {
	// public void run() {
// 	    // #1 delay expression
// 	    long delay = (long) ((org.plt.types.NumberTower.multiply
// 				  ((org.plt.types.Number)
// 				   WorldKernel.getFrameRate(),
// 				   new org.plt.types.Rational(1000, 1))).toInt());
// 	    while(! stopped) {
// 		repaint();
// 		if(((org.plt.types.Logic) WorldKernel.getStopWhenHandler().call(new Object[] {world})).isTrue()) {
// 		    //  #2 stop-when expression
// 		    stopped = true;
// 		} else {
// 		    try {
// 			Thread.sleep(delay);
// 		    } catch (InterruptedException e) {}
// 		    synchronized(world) {
// 			//  #3 on-tick expression
// 			world = WorldKernel.getOnTickHandler().call(new Object[] { world });
// 		    }
// 		}
// 	    }
// 	}


	public void paint(Graphics g) {
	    if (world == null)
		return;

            org.plt.gui.GraphicsAdapter ag = 
		new org.plt.gui.GraphicsAdapter(g);
	    // #4,5,6 on-redraw expression
	    org.plt.gui.DrawPicture pVisitor = 
		new org.plt.gui.DrawPicture(ag);
	    org.plt.gui.Scene aScene =
		(org.plt.gui.Scene) WorldKernel.getOnRedrawHandler().call
		(new Object[] {world});
	    aScene.accept(pVisitor, 0, 0);
	}


	protected void keyPressed(int keyCode) {
	    final Object aKey = translateKeyCode(keyCode);
	    runner.queueTransformer(new WorldTransformer() {
		    public Object transform(Object world) {
			return WorldKernel.getOnKeyEventHandler().call
			    (new Object[] {world, aKey});
		    }
		});
	}

	private Object translateKeyCode(int keyCode) {
	    switch(getGameAction(keyCode)) {
	    case Canvas.LEFT: return "left";
	    case Canvas.RIGHT: return "right"; 
	    case Canvas.UP: return "up";
	    case Canvas.DOWN: return "down";
	    default:
		if (keyCode > 0) {
		    return new Character((char)keyCode);
		} else {
		    return "";
		}
	    }
	}
    }
}
