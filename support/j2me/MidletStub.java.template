package org.plt.<<PROGRAM-NAME>>;

import javax.microedition.midlet.*;
import javax.microedition.lcdui.*;

import org.plt.platform.PlatformI;
import org.plt.platform.Platform;
import org.plt.world.MessageListener;
import org.plt.world.LocationChangeListener;
import org.plt.world.OrientationChangeListener;
import org.plt.world.AccelerationChangeListener;
import org.plt.WorldKernel;


// This is stub code.
// The following things must be plugged in:
// 
// PROGRAM-NAME
// PROGRAM-DEFINITIONS
// PROGRAM-TOPLEVEL-EXPRESSIONS
// ON-START
// ON-PAUSE
// ON-DESTROY


public class <<PROGRAM-NAME>> extends MIDlet {
    static class UserProgram {
        // Important: definitions must come first, because they'll
        // include static blocks that initialize values that
        // we depend on later!
        <<PROGRAM-DEFINITIONS>>
        public static void runToplevel() {
	    <<PROGRAM-TOPLEVEL-EXPRESSIONS>>;
	}
    }

    // #0 big-bang's world0
    Object world;
    boolean stopped = false;
    MyCanvas canvas;


    // When a program is paused, we'll restart the world.
    public void pauseApp() {
	world = WorldKernel.getInitialWorld();
	stopped = true;
	// IMPORTANT: The injected code here assumes the
	// presense of a 'listener' variable that
	// can be used to register callbacks.
	MyCanvas listener = canvas;
	<<ON-PAUSE>>
    }

    public void destroyApp(boolean unconditional) {
	world = WorldKernel.getInitialWorld();
	stopped = true;
	// IMPORTANT: The injected code here assumes the
	// presense of a 'listener' variable that
	// can be used to register callbacks.
	MyCanvas listener = canvas;
	<<ON-DESTROY>>
    }	


    public void startApp() {
	// debug: show the platform in the log.
	// System.out.println(Platform.getInstance().getName());

	UserProgram.runToplevel();
	world = WorldKernel.getInitialWorld();
	stopped = false;

	this.canvas = new MyCanvas();
	// IMPORTANT: The injected code here assumes the
	// presense of a 'listener' variable that
	// can be used to register callbacks.
	MyCanvas listener = canvas;
	<<ON-START>>

	Display.getDisplay(this).setCurrent(canvas);
	new Thread(canvas).start();
    }

    class MyCanvas extends Canvas implements Runnable, MessageListener, LocationChangeListener, OrientationChangeListener, AccelerationChangeListener {
	public void run() {
	    // #1 delay expression
	    long delay = (long) ((org.plt.types.NumberTower.multiply
				  ((org.plt.types.Number)
				   WorldKernel.getFrameRate(),
				   new org.plt.types.Rational(1000, 1))).toInt());
	    while(! stopped) {
		repaint();
		if(((org.plt.types.Logic) WorldKernel.getStopWhenHandler().call(new Object[] {world})).isTrue()) {
		    //  #2 stop-when expression
		    stopped = true;
		} else {
		    try {
			Thread.sleep(delay);
		    } catch (InterruptedException e) {}
		    synchronized(world) {
			//  #3 on-tick expression
			world = WorldKernel.getOnTickHandler().call(new Object[] { world });
		    }
		}
	    }
	}

        public void onMessage(Object aMessage) {
	    if (stopped)
		return;
	    synchronized(world) {
		world = WorldKernel.getOnMessageEventHandler().call
		    (new Object[] { world, aMessage});
	    }
	    repaint();
	}

	public void onLocationChange(Object latitude, Object longitude) {
	    if (stopped)
		return;

	    synchronized(world) {
		world = WorldKernel.getOnLocationChangeEventHandler().call
		    (new Object[] { world, latitude, longitude });
	    }	    
	    repaint();
	}

	public void onOrientationChange(Object azimuth, Object pitch, Object roll) {
	    if (stopped)
		return;

	    synchronized(world) {
		world = WorldKernel.getOnOrientationChangeEventHandler().call
		    (new Object[] { world, azimuth, pitch, roll });
	    }	    
	    repaint();
	}

	public void onAccelerationChange(Object x, Object y, Object z) {
	    if (stopped)
		return;

	    synchronized(world) {
		world = WorldKernel.getOnAccelerationChangeEventHandler().call
		    (new Object[] { world, x, y, z });
	    }	    
	    repaint();
	}


	public void paint(Graphics g) {
            org.plt.gui.GraphicsAdapter ag = new org.plt.gui.GraphicsAdapter(g);
	    // #4,5,6 on-redraw expression
	    org.plt.gui.DrawPicture pVisitor = new org.plt.gui.DrawPicture(ag);
	    org.plt.gui.Scene aScene = (org.plt.gui.Scene) WorldKernel.getOnRedrawHandler().call
		(new Object[] {world});
	    aScene.accept(pVisitor, 0, 0);
	}

	protected void keyPressed(int keyCode) {
	    if (stopped) { return; }

	    Object aKey;
	    switch(getGameAction(keyCode)) {
	    case Canvas.LEFT: aKey = "left"; break;
	    case Canvas.RIGHT: aKey = "right"; break;
	    case Canvas.UP: aKey = "up"; break;
	    case Canvas.DOWN: aKey = "down"; break;
	    default:
		if (keyCode > 0) {
		    aKey = new Character((char)keyCode);
		} else {
		    aKey= "";
		}
		break;
	    }
	    
	    synchronized(world) {
		world = WorldKernel.getOnKeyEventHandler().call
		    (new Object[] {world, aKey});
	    }
	    repaint();
	}
    }
}
